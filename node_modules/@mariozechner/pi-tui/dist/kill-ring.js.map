{"version":3,"file":"kill-ring.js","sourceRoot":"","sources":["../src/kill-ring.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AACH,MAAM,OAAO,QAAQ;IACZ,IAAI,GAAa,EAAE,CAAC;IAE5B;;;;;;;OAOG;IACH,IAAI,CAAC,IAAY,EAAE,IAAgD,EAAQ;QAC1E,IAAI,CAAC,IAAI;YAAE,OAAO;QAElB,IAAI,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC7C,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,EAAG,CAAC;YAC9B,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC;QAC1D,CAAC;aAAM,CAAC;YACP,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACtB,CAAC;IAAA,CACD;IAED,wDAAwD;IACxD,IAAI,GAAuB;QAC1B,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;IAAA,CAC1E;IAED,uDAAuD;IACvD,MAAM,GAAS;QACd,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC1B,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,EAAG,CAAC;YAC9B,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QACzB,CAAC;IAAA,CACD;IAED,IAAI,MAAM,GAAW;QACpB,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;IAAA,CACxB;CACD","sourcesContent":["/**\n * Ring buffer for Emacs-style kill/yank operations.\n *\n * Tracks killed (deleted) text entries. Consecutive kills can accumulate\n * into a single entry. Supports yank (paste most recent) and yank-pop\n * (cycle through older entries).\n */\nexport class KillRing {\n\tprivate ring: string[] = [];\n\n\t/**\n\t * Add text to the kill ring.\n\t *\n\t * @param text - The killed text to add\n\t * @param opts - Push options\n\t * @param opts.prepend - If accumulating, prepend (backward deletion) or append (forward deletion)\n\t * @param opts.accumulate - Merge with the most recent entry instead of creating a new one\n\t */\n\tpush(text: string, opts: { prepend: boolean; accumulate?: boolean }): void {\n\t\tif (!text) return;\n\n\t\tif (opts.accumulate && this.ring.length > 0) {\n\t\t\tconst last = this.ring.pop()!;\n\t\t\tthis.ring.push(opts.prepend ? text + last : last + text);\n\t\t} else {\n\t\t\tthis.ring.push(text);\n\t\t}\n\t}\n\n\t/** Get most recent entry without modifying the ring. */\n\tpeek(): string | undefined {\n\t\treturn this.ring.length > 0 ? this.ring[this.ring.length - 1] : undefined;\n\t}\n\n\t/** Move last entry to front (for yank-pop cycling). */\n\trotate(): void {\n\t\tif (this.ring.length > 1) {\n\t\t\tconst last = this.ring.pop()!;\n\t\t\tthis.ring.unshift(last);\n\t\t}\n\t}\n\n\tget length(): number {\n\t\treturn this.ring.length;\n\t}\n}\n"]}