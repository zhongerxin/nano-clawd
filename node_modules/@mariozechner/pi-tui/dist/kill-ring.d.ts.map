{"version":3,"file":"kill-ring.d.ts","sourceRoot":"","sources":["../src/kill-ring.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AACH,qBAAa,QAAQ;IACpB,OAAO,CAAC,IAAI,CAAgB;IAE5B;;;;;;;OAOG;IACH,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE;QAAE,OAAO,EAAE,OAAO,CAAC;QAAC,UAAU,CAAC,EAAE,OAAO,CAAA;KAAE,GAAG,IAAI,CASzE;IAED,wDAAwD;IACxD,IAAI,IAAI,MAAM,GAAG,SAAS,CAEzB;IAED,uDAAuD;IACvD,MAAM,IAAI,IAAI,CAKb;IAED,IAAI,MAAM,IAAI,MAAM,CAEnB;CACD","sourcesContent":["/**\n * Ring buffer for Emacs-style kill/yank operations.\n *\n * Tracks killed (deleted) text entries. Consecutive kills can accumulate\n * into a single entry. Supports yank (paste most recent) and yank-pop\n * (cycle through older entries).\n */\nexport class KillRing {\n\tprivate ring: string[] = [];\n\n\t/**\n\t * Add text to the kill ring.\n\t *\n\t * @param text - The killed text to add\n\t * @param opts - Push options\n\t * @param opts.prepend - If accumulating, prepend (backward deletion) or append (forward deletion)\n\t * @param opts.accumulate - Merge with the most recent entry instead of creating a new one\n\t */\n\tpush(text: string, opts: { prepend: boolean; accumulate?: boolean }): void {\n\t\tif (!text) return;\n\n\t\tif (opts.accumulate && this.ring.length > 0) {\n\t\t\tconst last = this.ring.pop()!;\n\t\t\tthis.ring.push(opts.prepend ? text + last : last + text);\n\t\t} else {\n\t\t\tthis.ring.push(text);\n\t\t}\n\t}\n\n\t/** Get most recent entry without modifying the ring. */\n\tpeek(): string | undefined {\n\t\treturn this.ring.length > 0 ? this.ring[this.ring.length - 1] : undefined;\n\t}\n\n\t/** Move last entry to front (for yank-pop cycling). */\n\trotate(): void {\n\t\tif (this.ring.length > 1) {\n\t\t\tconst last = this.ring.pop()!;\n\t\t\tthis.ring.unshift(last);\n\t\t}\n\t}\n\n\tget length(): number {\n\t\treturn this.ring.length;\n\t}\n}\n"]}