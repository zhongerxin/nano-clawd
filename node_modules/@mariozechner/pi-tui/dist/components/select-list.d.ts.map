{"version":3,"file":"select-list.d.ts","sourceRoot":"","sources":["../../src/components/select-list.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,SAAS,EAAE,MAAM,WAAW,CAAC;AAK3C,MAAM,WAAW,UAAU;IAC1B,KAAK,EAAE,MAAM,CAAC;IACd,KAAK,EAAE,MAAM,CAAC;IACd,WAAW,CAAC,EAAE,MAAM,CAAC;CACrB;AAED,MAAM,WAAW,eAAe;IAC/B,cAAc,EAAE,CAAC,IAAI,EAAE,MAAM,KAAK,MAAM,CAAC;IACzC,YAAY,EAAE,CAAC,IAAI,EAAE,MAAM,KAAK,MAAM,CAAC;IACvC,WAAW,EAAE,CAAC,IAAI,EAAE,MAAM,KAAK,MAAM,CAAC;IACtC,UAAU,EAAE,CAAC,IAAI,EAAE,MAAM,KAAK,MAAM,CAAC;IACrC,OAAO,EAAE,CAAC,IAAI,EAAE,MAAM,KAAK,MAAM,CAAC;CAClC;AAED,qBAAa,UAAW,YAAW,SAAS;IAC3C,OAAO,CAAC,KAAK,CAAoB;IACjC,OAAO,CAAC,aAAa,CAAoB;IACzC,OAAO,CAAC,aAAa,CAAa;IAClC,OAAO,CAAC,UAAU,CAAa;IAC/B,OAAO,CAAC,KAAK,CAAkB;IAExB,QAAQ,CAAC,EAAE,CAAC,IAAI,EAAE,UAAU,KAAK,IAAI,CAAC;IACtC,QAAQ,CAAC,EAAE,MAAM,IAAI,CAAC;IACtB,iBAAiB,CAAC,EAAE,CAAC,IAAI,EAAE,UAAU,KAAK,IAAI,CAAC;IAEtD,YAAY,KAAK,EAAE,UAAU,EAAE,EAAE,UAAU,EAAE,MAAM,EAAE,KAAK,EAAE,eAAe,EAK1E;IAED,SAAS,CAAC,MAAM,EAAE,MAAM,GAAG,IAAI,CAI9B;IAED,gBAAgB,CAAC,KAAK,EAAE,MAAM,GAAG,IAAI,CAEpC;IAED,UAAU,IAAI,IAAI,CAEjB;IAED,MAAM,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,EAAE,CA+F9B;IAED,WAAW,CAAC,OAAO,EAAE,MAAM,GAAG,IAAI,CAyBjC;IAED,OAAO,CAAC,qBAAqB;IAO7B,eAAe,IAAI,UAAU,GAAG,IAAI,CAGnC;CACD","sourcesContent":["import { getEditorKeybindings } from \"../keybindings.js\";\nimport type { Component } from \"../tui.js\";\nimport { truncateToWidth } from \"../utils.js\";\n\nconst normalizeToSingleLine = (text: string): string => text.replace(/[\\r\\n]+/g, \" \").trim();\n\nexport interface SelectItem {\n\tvalue: string;\n\tlabel: string;\n\tdescription?: string;\n}\n\nexport interface SelectListTheme {\n\tselectedPrefix: (text: string) => string;\n\tselectedText: (text: string) => string;\n\tdescription: (text: string) => string;\n\tscrollInfo: (text: string) => string;\n\tnoMatch: (text: string) => string;\n}\n\nexport class SelectList implements Component {\n\tprivate items: SelectItem[] = [];\n\tprivate filteredItems: SelectItem[] = [];\n\tprivate selectedIndex: number = 0;\n\tprivate maxVisible: number = 5;\n\tprivate theme: SelectListTheme;\n\n\tpublic onSelect?: (item: SelectItem) => void;\n\tpublic onCancel?: () => void;\n\tpublic onSelectionChange?: (item: SelectItem) => void;\n\n\tconstructor(items: SelectItem[], maxVisible: number, theme: SelectListTheme) {\n\t\tthis.items = items;\n\t\tthis.filteredItems = items;\n\t\tthis.maxVisible = maxVisible;\n\t\tthis.theme = theme;\n\t}\n\n\tsetFilter(filter: string): void {\n\t\tthis.filteredItems = this.items.filter((item) => item.value.toLowerCase().startsWith(filter.toLowerCase()));\n\t\t// Reset selection when filter changes\n\t\tthis.selectedIndex = 0;\n\t}\n\n\tsetSelectedIndex(index: number): void {\n\t\tthis.selectedIndex = Math.max(0, Math.min(index, this.filteredItems.length - 1));\n\t}\n\n\tinvalidate(): void {\n\t\t// No cached state to invalidate currently\n\t}\n\n\trender(width: number): string[] {\n\t\tconst lines: string[] = [];\n\n\t\t// If no items match filter, show message\n\t\tif (this.filteredItems.length === 0) {\n\t\t\tlines.push(this.theme.noMatch(\"  No matching commands\"));\n\t\t\treturn lines;\n\t\t}\n\n\t\t// Calculate visible range with scrolling\n\t\tconst startIndex = Math.max(\n\t\t\t0,\n\t\t\tMath.min(this.selectedIndex - Math.floor(this.maxVisible / 2), this.filteredItems.length - this.maxVisible),\n\t\t);\n\t\tconst endIndex = Math.min(startIndex + this.maxVisible, this.filteredItems.length);\n\n\t\t// Render visible items\n\t\tfor (let i = startIndex; i < endIndex; i++) {\n\t\t\tconst item = this.filteredItems[i];\n\t\t\tif (!item) continue;\n\n\t\t\tconst isSelected = i === this.selectedIndex;\n\t\t\tconst descriptionSingleLine = item.description ? normalizeToSingleLine(item.description) : undefined;\n\n\t\t\tlet line = \"\";\n\t\t\tif (isSelected) {\n\t\t\t\t// Use arrow indicator for selection - entire line uses selectedText color\n\t\t\t\tconst prefixWidth = 2; // \"→ \" is 2 characters visually\n\t\t\t\tconst displayValue = item.label || item.value;\n\n\t\t\t\tif (descriptionSingleLine && width > 40) {\n\t\t\t\t\t// Calculate how much space we have for value + description\n\t\t\t\t\tconst maxValueWidth = Math.min(30, width - prefixWidth - 4);\n\t\t\t\t\tconst truncatedValue = truncateToWidth(displayValue, maxValueWidth, \"\");\n\t\t\t\t\tconst spacing = \" \".repeat(Math.max(1, 32 - truncatedValue.length));\n\n\t\t\t\t\t// Calculate remaining space for description using visible widths\n\t\t\t\t\tconst descriptionStart = prefixWidth + truncatedValue.length + spacing.length;\n\t\t\t\t\tconst remainingWidth = width - descriptionStart - 2; // -2 for safety\n\n\t\t\t\t\tif (remainingWidth > 10) {\n\t\t\t\t\t\tconst truncatedDesc = truncateToWidth(descriptionSingleLine, remainingWidth, \"\");\n\t\t\t\t\t\t// Apply selectedText to entire line content\n\t\t\t\t\t\tline = this.theme.selectedText(`→ ${truncatedValue}${spacing}${truncatedDesc}`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Not enough space for description\n\t\t\t\t\t\tconst maxWidth = width - prefixWidth - 2;\n\t\t\t\t\t\tline = this.theme.selectedText(`→ ${truncateToWidth(displayValue, maxWidth, \"\")}`);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// No description or not enough width\n\t\t\t\t\tconst maxWidth = width - prefixWidth - 2;\n\t\t\t\t\tline = this.theme.selectedText(`→ ${truncateToWidth(displayValue, maxWidth, \"\")}`);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst displayValue = item.label || item.value;\n\t\t\t\tconst prefix = \"  \";\n\n\t\t\t\tif (descriptionSingleLine && width > 40) {\n\t\t\t\t\t// Calculate how much space we have for value + description\n\t\t\t\t\tconst maxValueWidth = Math.min(30, width - prefix.length - 4);\n\t\t\t\t\tconst truncatedValue = truncateToWidth(displayValue, maxValueWidth, \"\");\n\t\t\t\t\tconst spacing = \" \".repeat(Math.max(1, 32 - truncatedValue.length));\n\n\t\t\t\t\t// Calculate remaining space for description\n\t\t\t\t\tconst descriptionStart = prefix.length + truncatedValue.length + spacing.length;\n\t\t\t\t\tconst remainingWidth = width - descriptionStart - 2; // -2 for safety\n\n\t\t\t\t\tif (remainingWidth > 10) {\n\t\t\t\t\t\tconst truncatedDesc = truncateToWidth(descriptionSingleLine, remainingWidth, \"\");\n\t\t\t\t\t\tconst descText = this.theme.description(spacing + truncatedDesc);\n\t\t\t\t\t\tline = prefix + truncatedValue + descText;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Not enough space for description\n\t\t\t\t\t\tconst maxWidth = width - prefix.length - 2;\n\t\t\t\t\t\tline = prefix + truncateToWidth(displayValue, maxWidth, \"\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// No description or not enough width\n\t\t\t\t\tconst maxWidth = width - prefix.length - 2;\n\t\t\t\t\tline = prefix + truncateToWidth(displayValue, maxWidth, \"\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlines.push(line);\n\t\t}\n\n\t\t// Add scroll indicators if needed\n\t\tif (startIndex > 0 || endIndex < this.filteredItems.length) {\n\t\t\tconst scrollText = `  (${this.selectedIndex + 1}/${this.filteredItems.length})`;\n\t\t\t// Truncate if too long for terminal\n\t\t\tlines.push(this.theme.scrollInfo(truncateToWidth(scrollText, width - 2, \"\")));\n\t\t}\n\n\t\treturn lines;\n\t}\n\n\thandleInput(keyData: string): void {\n\t\tconst kb = getEditorKeybindings();\n\t\t// Up arrow - wrap to bottom when at top\n\t\tif (kb.matches(keyData, \"selectUp\")) {\n\t\t\tthis.selectedIndex = this.selectedIndex === 0 ? this.filteredItems.length - 1 : this.selectedIndex - 1;\n\t\t\tthis.notifySelectionChange();\n\t\t}\n\t\t// Down arrow - wrap to top when at bottom\n\t\telse if (kb.matches(keyData, \"selectDown\")) {\n\t\t\tthis.selectedIndex = this.selectedIndex === this.filteredItems.length - 1 ? 0 : this.selectedIndex + 1;\n\t\t\tthis.notifySelectionChange();\n\t\t}\n\t\t// Enter\n\t\telse if (kb.matches(keyData, \"selectConfirm\")) {\n\t\t\tconst selectedItem = this.filteredItems[this.selectedIndex];\n\t\t\tif (selectedItem && this.onSelect) {\n\t\t\t\tthis.onSelect(selectedItem);\n\t\t\t}\n\t\t}\n\t\t// Escape or Ctrl+C\n\t\telse if (kb.matches(keyData, \"selectCancel\")) {\n\t\t\tif (this.onCancel) {\n\t\t\t\tthis.onCancel();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate notifySelectionChange(): void {\n\t\tconst selectedItem = this.filteredItems[this.selectedIndex];\n\t\tif (selectedItem && this.onSelectionChange) {\n\t\t\tthis.onSelectionChange(selectedItem);\n\t\t}\n\t}\n\n\tgetSelectedItem(): SelectItem | null {\n\t\tconst item = this.filteredItems[this.selectedIndex];\n\t\treturn item || null;\n\t}\n}\n"]}