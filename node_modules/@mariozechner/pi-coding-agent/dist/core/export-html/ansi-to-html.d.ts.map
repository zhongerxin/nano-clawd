{"version":3,"file":"ansi-to-html.d.ts","sourceRoot":"","sources":["../../../src/core/export-html/ansi-to-html.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;GAWG;AAuLH;;GAEG;AACH,wBAAgB,UAAU,CAAC,IAAI,EAAE,MAAM,GAAG,MAAM,CAoD/C;AAED;;;GAGG;AACH,wBAAgB,eAAe,CAAC,KAAK,EAAE,MAAM,EAAE,GAAG,MAAM,CAEvD","sourcesContent":["/**\n * ANSI escape code to HTML converter.\n *\n * Converts terminal ANSI color/style codes to HTML with inline styles.\n * Supports:\n * - Standard foreground colors (30-37) and bright variants (90-97)\n * - Standard background colors (40-47) and bright variants (100-107)\n * - 256-color palette (38;5;N and 48;5;N)\n * - RGB true color (38;2;R;G;B and 48;2;R;G;B)\n * - Text styles: bold (1), dim (2), italic (3), underline (4)\n * - Reset (0)\n */\n\n// Standard ANSI color palette (0-15)\nconst ANSI_COLORS = [\n\t\"#000000\", // 0: black\n\t\"#800000\", // 1: red\n\t\"#008000\", // 2: green\n\t\"#808000\", // 3: yellow\n\t\"#000080\", // 4: blue\n\t\"#800080\", // 5: magenta\n\t\"#008080\", // 6: cyan\n\t\"#c0c0c0\", // 7: white\n\t\"#808080\", // 8: bright black\n\t\"#ff0000\", // 9: bright red\n\t\"#00ff00\", // 10: bright green\n\t\"#ffff00\", // 11: bright yellow\n\t\"#0000ff\", // 12: bright blue\n\t\"#ff00ff\", // 13: bright magenta\n\t\"#00ffff\", // 14: bright cyan\n\t\"#ffffff\", // 15: bright white\n];\n\n/**\n * Convert 256-color index to hex.\n */\nfunction color256ToHex(index: number): string {\n\t// Standard colors (0-15)\n\tif (index < 16) {\n\t\treturn ANSI_COLORS[index];\n\t}\n\n\t// Color cube (16-231): 6x6x6 = 216 colors\n\tif (index < 232) {\n\t\tconst cubeIndex = index - 16;\n\t\tconst r = Math.floor(cubeIndex / 36);\n\t\tconst g = Math.floor((cubeIndex % 36) / 6);\n\t\tconst b = cubeIndex % 6;\n\t\tconst toComponent = (n: number) => (n === 0 ? 0 : 55 + n * 40);\n\t\tconst toHex = (n: number) => toComponent(n).toString(16).padStart(2, \"0\");\n\t\treturn `#${toHex(r)}${toHex(g)}${toHex(b)}`;\n\t}\n\n\t// Grayscale (232-255): 24 shades\n\tconst gray = 8 + (index - 232) * 10;\n\tconst grayHex = gray.toString(16).padStart(2, \"0\");\n\treturn `#${grayHex}${grayHex}${grayHex}`;\n}\n\n/**\n * Escape HTML special characters.\n */\nfunction escapeHtml(text: string): string {\n\treturn text\n\t\t.replace(/&/g, \"&amp;\")\n\t\t.replace(/</g, \"&lt;\")\n\t\t.replace(/>/g, \"&gt;\")\n\t\t.replace(/\"/g, \"&quot;\")\n\t\t.replace(/'/g, \"&#039;\");\n}\n\ninterface TextStyle {\n\tfg: string | null;\n\tbg: string | null;\n\tbold: boolean;\n\tdim: boolean;\n\titalic: boolean;\n\tunderline: boolean;\n}\n\nfunction createEmptyStyle(): TextStyle {\n\treturn {\n\t\tfg: null,\n\t\tbg: null,\n\t\tbold: false,\n\t\tdim: false,\n\t\titalic: false,\n\t\tunderline: false,\n\t};\n}\n\nfunction styleToInlineCSS(style: TextStyle): string {\n\tconst parts: string[] = [];\n\tif (style.fg) parts.push(`color:${style.fg}`);\n\tif (style.bg) parts.push(`background-color:${style.bg}`);\n\tif (style.bold) parts.push(\"font-weight:bold\");\n\tif (style.dim) parts.push(\"opacity:0.6\");\n\tif (style.italic) parts.push(\"font-style:italic\");\n\tif (style.underline) parts.push(\"text-decoration:underline\");\n\treturn parts.join(\";\");\n}\n\nfunction hasStyle(style: TextStyle): boolean {\n\treturn style.fg !== null || style.bg !== null || style.bold || style.dim || style.italic || style.underline;\n}\n\n/**\n * Parse ANSI SGR (Select Graphic Rendition) codes and update style.\n */\nfunction applySgrCode(params: number[], style: TextStyle): void {\n\tlet i = 0;\n\twhile (i < params.length) {\n\t\tconst code = params[i];\n\n\t\tif (code === 0) {\n\t\t\t// Reset all\n\t\t\tstyle.fg = null;\n\t\t\tstyle.bg = null;\n\t\t\tstyle.bold = false;\n\t\t\tstyle.dim = false;\n\t\t\tstyle.italic = false;\n\t\t\tstyle.underline = false;\n\t\t} else if (code === 1) {\n\t\t\tstyle.bold = true;\n\t\t} else if (code === 2) {\n\t\t\tstyle.dim = true;\n\t\t} else if (code === 3) {\n\t\t\tstyle.italic = true;\n\t\t} else if (code === 4) {\n\t\t\tstyle.underline = true;\n\t\t} else if (code === 22) {\n\t\t\t// Reset bold/dim\n\t\t\tstyle.bold = false;\n\t\t\tstyle.dim = false;\n\t\t} else if (code === 23) {\n\t\t\tstyle.italic = false;\n\t\t} else if (code === 24) {\n\t\t\tstyle.underline = false;\n\t\t} else if (code >= 30 && code <= 37) {\n\t\t\t// Standard foreground colors\n\t\t\tstyle.fg = ANSI_COLORS[code - 30];\n\t\t} else if (code === 38) {\n\t\t\t// Extended foreground color\n\t\t\tif (params[i + 1] === 5 && params.length > i + 2) {\n\t\t\t\t// 256-color: 38;5;N\n\t\t\t\tstyle.fg = color256ToHex(params[i + 2]);\n\t\t\t\ti += 2;\n\t\t\t} else if (params[i + 1] === 2 && params.length > i + 4) {\n\t\t\t\t// RGB: 38;2;R;G;B\n\t\t\t\tconst r = params[i + 2];\n\t\t\t\tconst g = params[i + 3];\n\t\t\t\tconst b = params[i + 4];\n\t\t\t\tstyle.fg = `rgb(${r},${g},${b})`;\n\t\t\t\ti += 4;\n\t\t\t}\n\t\t} else if (code === 39) {\n\t\t\t// Default foreground\n\t\t\tstyle.fg = null;\n\t\t} else if (code >= 40 && code <= 47) {\n\t\t\t// Standard background colors\n\t\t\tstyle.bg = ANSI_COLORS[code - 40];\n\t\t} else if (code === 48) {\n\t\t\t// Extended background color\n\t\t\tif (params[i + 1] === 5 && params.length > i + 2) {\n\t\t\t\t// 256-color: 48;5;N\n\t\t\t\tstyle.bg = color256ToHex(params[i + 2]);\n\t\t\t\ti += 2;\n\t\t\t} else if (params[i + 1] === 2 && params.length > i + 4) {\n\t\t\t\t// RGB: 48;2;R;G;B\n\t\t\t\tconst r = params[i + 2];\n\t\t\t\tconst g = params[i + 3];\n\t\t\t\tconst b = params[i + 4];\n\t\t\t\tstyle.bg = `rgb(${r},${g},${b})`;\n\t\t\t\ti += 4;\n\t\t\t}\n\t\t} else if (code === 49) {\n\t\t\t// Default background\n\t\t\tstyle.bg = null;\n\t\t} else if (code >= 90 && code <= 97) {\n\t\t\t// Bright foreground colors\n\t\t\tstyle.fg = ANSI_COLORS[code - 90 + 8];\n\t\t} else if (code >= 100 && code <= 107) {\n\t\t\t// Bright background colors\n\t\t\tstyle.bg = ANSI_COLORS[code - 100 + 8];\n\t\t}\n\t\t// Ignore unrecognized codes\n\n\t\ti++;\n\t}\n}\n\n// Match ANSI escape sequences: ESC[ followed by params and ending with 'm'\nconst ANSI_REGEX = /\\x1b\\[([\\d;]*)m/g;\n\n/**\n * Convert ANSI-escaped text to HTML with inline styles.\n */\nexport function ansiToHtml(text: string): string {\n\tconst style = createEmptyStyle();\n\tlet result = \"\";\n\tlet lastIndex = 0;\n\tlet inSpan = false;\n\n\t// Reset regex state\n\tANSI_REGEX.lastIndex = 0;\n\n\tlet match = ANSI_REGEX.exec(text);\n\twhile (match !== null) {\n\t\t// Add text before this escape sequence\n\t\tconst beforeText = text.slice(lastIndex, match.index);\n\t\tif (beforeText) {\n\t\t\tresult += escapeHtml(beforeText);\n\t\t}\n\n\t\t// Parse SGR parameters\n\t\tconst paramStr = match[1];\n\t\tconst params = paramStr ? paramStr.split(\";\").map((p) => parseInt(p, 10) || 0) : [0];\n\n\t\t// Close existing span if we have one\n\t\tif (inSpan) {\n\t\t\tresult += \"</span>\";\n\t\t\tinSpan = false;\n\t\t}\n\n\t\t// Apply the codes\n\t\tapplySgrCode(params, style);\n\n\t\t// Open new span if we have any styling\n\t\tif (hasStyle(style)) {\n\t\t\tresult += `<span style=\"${styleToInlineCSS(style)}\">`;\n\t\t\tinSpan = true;\n\t\t}\n\n\t\tlastIndex = match.index + match[0].length;\n\t\tmatch = ANSI_REGEX.exec(text);\n\t}\n\n\t// Add remaining text\n\tconst remainingText = text.slice(lastIndex);\n\tif (remainingText) {\n\t\tresult += escapeHtml(remainingText);\n\t}\n\n\t// Close any open span\n\tif (inSpan) {\n\t\tresult += \"</span>\";\n\t}\n\n\treturn result;\n}\n\n/**\n * Convert array of ANSI-escaped lines to HTML.\n * Each line is wrapped in a div element.\n */\nexport function ansiLinesToHtml(lines: string[]): string {\n\treturn lines.map((line) => `<div class=\"ansi-line\">${ansiToHtml(line) || \"&nbsp;\"}</div>`).join(\"\\n\");\n}\n"]}