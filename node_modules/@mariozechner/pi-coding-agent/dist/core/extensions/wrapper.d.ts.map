{"version":3,"file":"wrapper.d.ts","sourceRoot":"","sources":["../../../src/core/extensions/wrapper.ts"],"names":[],"mappings":"AAAA;;GAEG;AAEH,OAAO,KAAK,EAAE,SAAS,EAA2B,MAAM,6BAA6B,CAAC;AACtF,OAAO,KAAK,EAAE,eAAe,EAAE,MAAM,aAAa,CAAC;AACnD,OAAO,KAAK,EAAE,cAAc,EAAuB,MAAM,YAAY,CAAC;AAEtE;;;GAGG;AACH,wBAAgB,kBAAkB,CAAC,cAAc,EAAE,cAAc,EAAE,MAAM,EAAE,eAAe,GAAG,SAAS,CAUrG;AAED;;;GAGG;AACH,wBAAgB,mBAAmB,CAAC,eAAe,EAAE,cAAc,EAAE,EAAE,MAAM,EAAE,eAAe,GAAG,SAAS,EAAE,CAE3G;AAED;;;;GAIG;AACH,wBAAgB,sBAAsB,CAAC,CAAC,EAAE,IAAI,EAAE,SAAS,CAAC,GAAG,EAAE,CAAC,CAAC,EAAE,MAAM,EAAE,eAAe,GAAG,SAAS,CAAC,GAAG,EAAE,CAAC,CAAC,CAyE7G;AAED;;GAEG;AACH,wBAAgB,uBAAuB,CAAC,CAAC,EAAE,KAAK,EAAE,SAAS,CAAC,GAAG,EAAE,CAAC,CAAC,EAAE,EAAE,MAAM,EAAE,eAAe,GAAG,SAAS,CAAC,GAAG,EAAE,CAAC,CAAC,EAAE,CAEnH","sourcesContent":["/**\n * Tool wrappers for extensions.\n */\n\nimport type { AgentTool, AgentToolUpdateCallback } from \"@mariozechner/pi-agent-core\";\nimport type { ExtensionRunner } from \"./runner.js\";\nimport type { RegisteredTool, ToolCallEventResult } from \"./types.js\";\n\n/**\n * Wrap a RegisteredTool into an AgentTool.\n * Uses the runner's createContext() for consistent context across tools and event handlers.\n */\nexport function wrapRegisteredTool(registeredTool: RegisteredTool, runner: ExtensionRunner): AgentTool {\n\tconst { definition } = registeredTool;\n\treturn {\n\t\tname: definition.name,\n\t\tlabel: definition.label,\n\t\tdescription: definition.description,\n\t\tparameters: definition.parameters,\n\t\texecute: (toolCallId, params, signal, onUpdate) =>\n\t\t\tdefinition.execute(toolCallId, params, signal, onUpdate, runner.createContext()),\n\t};\n}\n\n/**\n * Wrap all registered tools into AgentTools.\n * Uses the runner's createContext() for consistent context across tools and event handlers.\n */\nexport function wrapRegisteredTools(registeredTools: RegisteredTool[], runner: ExtensionRunner): AgentTool[] {\n\treturn registeredTools.map((rt) => wrapRegisteredTool(rt, runner));\n}\n\n/**\n * Wrap a tool with extension callbacks for interception.\n * - Emits tool_call event before execution (can block)\n * - Emits tool_result event after execution (can modify result)\n */\nexport function wrapToolWithExtensions<T>(tool: AgentTool<any, T>, runner: ExtensionRunner): AgentTool<any, T> {\n\treturn {\n\t\t...tool,\n\t\texecute: async (\n\t\t\ttoolCallId: string,\n\t\t\tparams: Record<string, unknown>,\n\t\t\tsignal?: AbortSignal,\n\t\t\tonUpdate?: AgentToolUpdateCallback<T>,\n\t\t) => {\n\t\t\t// Emit tool_call event - extensions can block execution\n\t\t\tif (runner.hasHandlers(\"tool_call\")) {\n\t\t\t\ttry {\n\t\t\t\t\tconst callResult = (await runner.emitToolCall({\n\t\t\t\t\t\ttype: \"tool_call\",\n\t\t\t\t\t\ttoolName: tool.name,\n\t\t\t\t\t\ttoolCallId,\n\t\t\t\t\t\tinput: params,\n\t\t\t\t\t})) as ToolCallEventResult | undefined;\n\n\t\t\t\t\tif (callResult?.block) {\n\t\t\t\t\t\tconst reason = callResult.reason || \"Tool execution was blocked by an extension\";\n\t\t\t\t\t\tthrow new Error(reason);\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (err instanceof Error) {\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error(`Extension failed, blocking execution: ${String(err)}`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Execute the actual tool\n\t\t\ttry {\n\t\t\t\tconst result = await tool.execute(toolCallId, params, signal, onUpdate);\n\n\t\t\t\t// Emit tool_result event - extensions can modify the result\n\t\t\t\tif (runner.hasHandlers(\"tool_result\")) {\n\t\t\t\t\tconst resultResult = await runner.emitToolResult({\n\t\t\t\t\t\ttype: \"tool_result\",\n\t\t\t\t\t\ttoolName: tool.name,\n\t\t\t\t\t\ttoolCallId,\n\t\t\t\t\t\tinput: params,\n\t\t\t\t\t\tcontent: result.content,\n\t\t\t\t\t\tdetails: result.details,\n\t\t\t\t\t\tisError: false,\n\t\t\t\t\t});\n\n\t\t\t\t\tif (resultResult) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tcontent: resultResult.content ?? result.content,\n\t\t\t\t\t\t\tdetails: (resultResult.details ?? result.details) as T,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t} catch (err) {\n\t\t\t\t// Emit tool_result event for errors\n\t\t\t\tif (runner.hasHandlers(\"tool_result\")) {\n\t\t\t\t\tawait runner.emitToolResult({\n\t\t\t\t\t\ttype: \"tool_result\",\n\t\t\t\t\t\ttoolName: tool.name,\n\t\t\t\t\t\ttoolCallId,\n\t\t\t\t\t\tinput: params,\n\t\t\t\t\t\tcontent: [{ type: \"text\", text: err instanceof Error ? err.message : String(err) }],\n\t\t\t\t\t\tdetails: undefined,\n\t\t\t\t\t\tisError: true,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t},\n\t};\n}\n\n/**\n * Wrap all tools with extension callbacks.\n */\nexport function wrapToolsWithExtensions<T>(tools: AgentTool<any, T>[], runner: ExtensionRunner): AgentTool<any, T>[] {\n\treturn tools.map((tool) => wrapToolWithExtensions(tool, runner));\n}\n"]}