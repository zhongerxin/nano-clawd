{"version":3,"file":"tool-execution.d.ts","sourceRoot":"","sources":["../../../../src/modes/interactive/components/tool-execution.ts"],"names":[],"mappings":"AACA,OAAO,EAEN,SAAS,EAOT,KAAK,GAAG,EAER,MAAM,sBAAsB,CAAC;AAE9B,OAAO,KAAK,EAAE,cAAc,EAAE,MAAM,mCAAmC,CAAC;AAwCxE,MAAM,WAAW,oBAAoB;IACpC,UAAU,CAAC,EAAE,OAAO,CAAC;CACrB;AAED;;GAEG;AACH,qBAAa,sBAAuB,SAAQ,SAAS;IACpD,OAAO,CAAC,UAAU,CAAM;IACxB,OAAO,CAAC,WAAW,CAAO;IAC1B,OAAO,CAAC,eAAe,CAAe;IACtC,OAAO,CAAC,YAAY,CAAgB;IACpC,OAAO,CAAC,QAAQ,CAAS;IACzB,OAAO,CAAC,IAAI,CAAM;IAClB,OAAO,CAAC,QAAQ,CAAS;IACzB,OAAO,CAAC,UAAU,CAAU;IAC5B,OAAO,CAAC,SAAS,CAAQ;IACzB,OAAO,CAAC,cAAc,CAAC,CAAiB;IACxC,OAAO,CAAC,EAAE,CAAM;IAChB,OAAO,CAAC,GAAG,CAAS;IACpB,OAAO,CAAC,MAAM,CAAC,CAIb;IAEF,OAAO,CAAC,eAAe,CAAC,CAAiC;IACzD,OAAO,CAAC,eAAe,CAAC,CAAS;IAEjC,OAAO,CAAC,eAAe,CAA8D;IAErF,YACC,QAAQ,EAAE,MAAM,EAChB,IAAI,EAAE,GAAG,EACT,OAAO,kCAA2B,EAClC,cAAc,EAAE,cAAc,GAAG,SAAS,EAC1C,EAAE,EAAE,GAAG,EACP,GAAG,GAAE,MAAsB,EAyB3B;IAED;;;;OAIG;IACH,OAAO,CAAC,wBAAwB;IAMhC,UAAU,CAAC,IAAI,EAAE,GAAG,GAAG,IAAI,CAG1B;IAED;;;OAGG;IACH,eAAe,IAAI,IAAI,CAEtB;IAED;;;OAGG;IACH,OAAO,CAAC,oBAAoB;IA6B5B,YAAY,CACX,MAAM,EAAE;QACP,OAAO,EAAE,KAAK,CAAC;YAAE,IAAI,EAAE,MAAM,CAAC;YAAC,IAAI,CAAC,EAAE,MAAM,CAAC;YAAC,IAAI,CAAC,EAAE,MAAM,CAAC;YAAC,QAAQ,CAAC,EAAE,MAAM,CAAA;SAAE,CAAC,CAAC;QAClF,OAAO,CAAC,EAAE,GAAG,CAAC;QACd,OAAO,EAAE,OAAO,CAAC;KACjB,EACD,SAAS,UAAQ,GACf,IAAI,CAMN;IAED;;;OAGG;IACH,OAAO,CAAC,0BAA0B;IA2BlC,WAAW,CAAC,QAAQ,EAAE,OAAO,GAAG,IAAI,CAGnC;IAED,aAAa,CAAC,IAAI,EAAE,OAAO,GAAG,IAAI,CAGjC;IAEQ,UAAU,IAAI,IAAI,CAG1B;IAED,OAAO,CAAC,aAAa;IA+GrB;;OAEG;IACH,OAAO,CAAC,iBAAiB;IA+EzB,OAAO,CAAC,aAAa;IA2BrB,OAAO,CAAC,mBAAmB;CA0R3B","sourcesContent":["import * as os from \"node:os\";\nimport {\n\tBox,\n\tContainer,\n\tgetCapabilities,\n\tgetImageDimensions,\n\tImage,\n\timageFallback,\n\tSpacer,\n\tText,\n\ttype TUI,\n\ttruncateToWidth,\n} from \"@mariozechner/pi-tui\";\nimport stripAnsi from \"strip-ansi\";\nimport type { ToolDefinition } from \"../../../core/extensions/types.js\";\nimport { computeEditDiff, type EditDiffError, type EditDiffResult } from \"../../../core/tools/edit-diff.js\";\nimport { allTools } from \"../../../core/tools/index.js\";\nimport { DEFAULT_MAX_BYTES, DEFAULT_MAX_LINES, formatSize } from \"../../../core/tools/truncate.js\";\nimport { convertToPng } from \"../../../utils/image-convert.js\";\nimport { sanitizeBinaryOutput } from \"../../../utils/shell.js\";\nimport { getLanguageFromPath, highlightCode, theme } from \"../theme/theme.js\";\nimport { renderDiff } from \"./diff.js\";\nimport { keyHint } from \"./keybinding-hints.js\";\nimport { truncateToVisualLines } from \"./visual-truncate.js\";\n\n// Preview line limit for bash when not expanded\nconst BASH_PREVIEW_LINES = 5;\n\n/**\n * Convert absolute path to tilde notation if it's in home directory\n */\nfunction shortenPath(path: unknown): string {\n\tif (typeof path !== \"string\") return \"\";\n\tconst home = os.homedir();\n\tif (path.startsWith(home)) {\n\t\treturn `~${path.slice(home.length)}`;\n\t}\n\treturn path;\n}\n\n/**\n * Replace tabs with spaces for consistent rendering\n */\nfunction replaceTabs(text: string): string {\n\treturn text.replace(/\\t/g, \"   \");\n}\n\n/** Safely coerce value to string for display. Returns null if invalid type. */\nfunction str(value: unknown): string | null {\n\tif (typeof value === \"string\") return value;\n\tif (value == null) return \"\";\n\treturn null; // Invalid type\n}\n\nexport interface ToolExecutionOptions {\n\tshowImages?: boolean; // default: true (only used if terminal supports images)\n}\n\n/**\n * Component that renders a tool call with its result (updateable)\n */\nexport class ToolExecutionComponent extends Container {\n\tprivate contentBox: Box; // Used for custom tools and bash visual truncation\n\tprivate contentText: Text; // For built-in tools (with its own padding/bg)\n\tprivate imageComponents: Image[] = [];\n\tprivate imageSpacers: Spacer[] = [];\n\tprivate toolName: string;\n\tprivate args: any;\n\tprivate expanded = false;\n\tprivate showImages: boolean;\n\tprivate isPartial = true;\n\tprivate toolDefinition?: ToolDefinition;\n\tprivate ui: TUI;\n\tprivate cwd: string;\n\tprivate result?: {\n\t\tcontent: Array<{ type: string; text?: string; data?: string; mimeType?: string }>;\n\t\tisError: boolean;\n\t\tdetails?: any;\n\t};\n\t// Cached edit diff preview (computed when args arrive, before tool executes)\n\tprivate editDiffPreview?: EditDiffResult | EditDiffError;\n\tprivate editDiffArgsKey?: string; // Track which args the preview is for\n\t// Cached converted images for Kitty protocol (which requires PNG), keyed by index\n\tprivate convertedImages: Map<number, { data: string; mimeType: string }> = new Map();\n\n\tconstructor(\n\t\ttoolName: string,\n\t\targs: any,\n\t\toptions: ToolExecutionOptions = {},\n\t\ttoolDefinition: ToolDefinition | undefined,\n\t\tui: TUI,\n\t\tcwd: string = process.cwd(),\n\t) {\n\t\tsuper();\n\t\tthis.toolName = toolName;\n\t\tthis.args = args;\n\t\tthis.showImages = options.showImages ?? true;\n\t\tthis.toolDefinition = toolDefinition;\n\t\tthis.ui = ui;\n\t\tthis.cwd = cwd;\n\n\t\tthis.addChild(new Spacer(1));\n\n\t\t// Always create both - contentBox for custom tools/bash, contentText for other built-ins\n\t\tthis.contentBox = new Box(1, 1, (text: string) => theme.bg(\"toolPendingBg\", text));\n\t\tthis.contentText = new Text(\"\", 1, 1, (text: string) => theme.bg(\"toolPendingBg\", text));\n\n\t\t// Use contentBox for bash (visual truncation) or custom tools with custom renderers\n\t\t// Use contentText for built-in tools (including overrides without custom renderers)\n\t\tif (toolName === \"bash\" || (toolDefinition && !this.shouldUseBuiltInRenderer())) {\n\t\t\tthis.addChild(this.contentBox);\n\t\t} else {\n\t\t\tthis.addChild(this.contentText);\n\t\t}\n\n\t\tthis.updateDisplay();\n\t}\n\n\t/**\n\t * Check if we should use built-in rendering for this tool.\n\t * Returns true if the tool name is a built-in AND either there's no toolDefinition\n\t * or the toolDefinition doesn't provide custom renderers.\n\t */\n\tprivate shouldUseBuiltInRenderer(): boolean {\n\t\tconst isBuiltInName = this.toolName in allTools;\n\t\tconst hasCustomRenderers = this.toolDefinition?.renderCall || this.toolDefinition?.renderResult;\n\t\treturn isBuiltInName && !hasCustomRenderers;\n\t}\n\n\tupdateArgs(args: any): void {\n\t\tthis.args = args;\n\t\tthis.updateDisplay();\n\t}\n\n\t/**\n\t * Signal that args are complete (tool is about to execute).\n\t * This triggers diff computation for edit tool.\n\t */\n\tsetArgsComplete(): void {\n\t\tthis.maybeComputeEditDiff();\n\t}\n\n\t/**\n\t * Compute edit diff preview when we have complete args.\n\t * This runs async and updates display when done.\n\t */\n\tprivate maybeComputeEditDiff(): void {\n\t\tif (this.toolName !== \"edit\") return;\n\n\t\tconst path = this.args?.path;\n\t\tconst oldText = this.args?.oldText;\n\t\tconst newText = this.args?.newText;\n\n\t\t// Need all three params to compute diff\n\t\tif (!path || oldText === undefined || newText === undefined) return;\n\n\t\t// Create a key to track which args this computation is for\n\t\tconst argsKey = JSON.stringify({ path, oldText, newText });\n\n\t\t// Skip if we already computed for these exact args\n\t\tif (this.editDiffArgsKey === argsKey) return;\n\n\t\tthis.editDiffArgsKey = argsKey;\n\n\t\t// Compute diff async\n\t\tcomputeEditDiff(path, oldText, newText, this.cwd).then((result) => {\n\t\t\t// Only update if args haven't changed since we started\n\t\t\tif (this.editDiffArgsKey === argsKey) {\n\t\t\t\tthis.editDiffPreview = result;\n\t\t\t\tthis.updateDisplay();\n\t\t\t\tthis.ui.requestRender();\n\t\t\t}\n\t\t});\n\t}\n\n\tupdateResult(\n\t\tresult: {\n\t\t\tcontent: Array<{ type: string; text?: string; data?: string; mimeType?: string }>;\n\t\t\tdetails?: any;\n\t\t\tisError: boolean;\n\t\t},\n\t\tisPartial = false,\n\t): void {\n\t\tthis.result = result;\n\t\tthis.isPartial = isPartial;\n\t\tthis.updateDisplay();\n\t\t// Convert non-PNG images to PNG for Kitty protocol (async)\n\t\tthis.maybeConvertImagesForKitty();\n\t}\n\n\t/**\n\t * Convert non-PNG images to PNG for Kitty graphics protocol.\n\t * Kitty requires PNG format (f=100), so JPEG/GIF/WebP won't display.\n\t */\n\tprivate maybeConvertImagesForKitty(): void {\n\t\tconst caps = getCapabilities();\n\t\t// Only needed for Kitty protocol\n\t\tif (caps.images !== \"kitty\") return;\n\t\tif (!this.result) return;\n\n\t\tconst imageBlocks = this.result.content?.filter((c: any) => c.type === \"image\") || [];\n\n\t\tfor (let i = 0; i < imageBlocks.length; i++) {\n\t\t\tconst img = imageBlocks[i];\n\t\t\tif (!img.data || !img.mimeType) continue;\n\t\t\t// Skip if already PNG or already converted\n\t\t\tif (img.mimeType === \"image/png\") continue;\n\t\t\tif (this.convertedImages.has(i)) continue;\n\n\t\t\t// Convert async\n\t\t\tconst index = i;\n\t\t\tconvertToPng(img.data, img.mimeType).then((converted) => {\n\t\t\t\tif (converted) {\n\t\t\t\t\tthis.convertedImages.set(index, converted);\n\t\t\t\t\tthis.updateDisplay();\n\t\t\t\t\tthis.ui.requestRender();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tsetExpanded(expanded: boolean): void {\n\t\tthis.expanded = expanded;\n\t\tthis.updateDisplay();\n\t}\n\n\tsetShowImages(show: boolean): void {\n\t\tthis.showImages = show;\n\t\tthis.updateDisplay();\n\t}\n\n\toverride invalidate(): void {\n\t\tsuper.invalidate();\n\t\tthis.updateDisplay();\n\t}\n\n\tprivate updateDisplay(): void {\n\t\t// Set background based on state\n\t\tconst bgFn = this.isPartial\n\t\t\t? (text: string) => theme.bg(\"toolPendingBg\", text)\n\t\t\t: this.result?.isError\n\t\t\t\t? (text: string) => theme.bg(\"toolErrorBg\", text)\n\t\t\t\t: (text: string) => theme.bg(\"toolSuccessBg\", text);\n\n\t\t// Use built-in rendering for built-in tools (or overrides without custom renderers)\n\t\tif (this.shouldUseBuiltInRenderer()) {\n\t\t\tif (this.toolName === \"bash\") {\n\t\t\t\t// Bash uses Box with visual line truncation\n\t\t\t\tthis.contentBox.setBgFn(bgFn);\n\t\t\t\tthis.contentBox.clear();\n\t\t\t\tthis.renderBashContent();\n\t\t\t} else {\n\t\t\t\t// Other built-in tools: use Text directly with caching\n\t\t\t\tthis.contentText.setCustomBgFn(bgFn);\n\t\t\t\tthis.contentText.setText(this.formatToolExecution());\n\t\t\t}\n\t\t} else if (this.toolDefinition) {\n\t\t\t// Custom tools use Box for flexible component rendering\n\t\t\tthis.contentBox.setBgFn(bgFn);\n\t\t\tthis.contentBox.clear();\n\n\t\t\t// Render call component\n\t\t\tif (this.toolDefinition.renderCall) {\n\t\t\t\ttry {\n\t\t\t\t\tconst callComponent = this.toolDefinition.renderCall(this.args, theme);\n\t\t\t\t\tif (callComponent) {\n\t\t\t\t\t\tthis.contentBox.addChild(callComponent);\n\t\t\t\t\t}\n\t\t\t\t} catch {\n\t\t\t\t\t// Fall back to default on error\n\t\t\t\t\tthis.contentBox.addChild(new Text(theme.fg(\"toolTitle\", theme.bold(this.toolName)), 0, 0));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No custom renderCall, show tool name\n\t\t\t\tthis.contentBox.addChild(new Text(theme.fg(\"toolTitle\", theme.bold(this.toolName)), 0, 0));\n\t\t\t}\n\n\t\t\t// Render result component if we have a result\n\t\t\tif (this.result && this.toolDefinition.renderResult) {\n\t\t\t\ttry {\n\t\t\t\t\tconst resultComponent = this.toolDefinition.renderResult(\n\t\t\t\t\t\t{ content: this.result.content as any, details: this.result.details },\n\t\t\t\t\t\t{ expanded: this.expanded, isPartial: this.isPartial },\n\t\t\t\t\t\ttheme,\n\t\t\t\t\t);\n\t\t\t\t\tif (resultComponent) {\n\t\t\t\t\t\tthis.contentBox.addChild(resultComponent);\n\t\t\t\t\t}\n\t\t\t\t} catch {\n\t\t\t\t\t// Fall back to showing raw output on error\n\t\t\t\t\tconst output = this.getTextOutput();\n\t\t\t\t\tif (output) {\n\t\t\t\t\t\tthis.contentBox.addChild(new Text(theme.fg(\"toolOutput\", output), 0, 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (this.result) {\n\t\t\t\t// Has result but no custom renderResult\n\t\t\t\tconst output = this.getTextOutput();\n\t\t\t\tif (output) {\n\t\t\t\t\tthis.contentBox.addChild(new Text(theme.fg(\"toolOutput\", output), 0, 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Handle images (same for both custom and built-in)\n\t\tfor (const img of this.imageComponents) {\n\t\t\tthis.removeChild(img);\n\t\t}\n\t\tthis.imageComponents = [];\n\t\tfor (const spacer of this.imageSpacers) {\n\t\t\tthis.removeChild(spacer);\n\t\t}\n\t\tthis.imageSpacers = [];\n\n\t\tif (this.result) {\n\t\t\tconst imageBlocks = this.result.content?.filter((c: any) => c.type === \"image\") || [];\n\t\t\tconst caps = getCapabilities();\n\n\t\t\tfor (let i = 0; i < imageBlocks.length; i++) {\n\t\t\t\tconst img = imageBlocks[i];\n\t\t\t\tif (caps.images && this.showImages && img.data && img.mimeType) {\n\t\t\t\t\t// Use converted PNG for Kitty protocol if available\n\t\t\t\t\tconst converted = this.convertedImages.get(i);\n\t\t\t\t\tconst imageData = converted?.data ?? img.data;\n\t\t\t\t\tconst imageMimeType = converted?.mimeType ?? img.mimeType;\n\n\t\t\t\t\t// For Kitty, skip non-PNG images that haven't been converted yet\n\t\t\t\t\tif (caps.images === \"kitty\" && imageMimeType !== \"image/png\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst spacer = new Spacer(1);\n\t\t\t\t\tthis.addChild(spacer);\n\t\t\t\t\tthis.imageSpacers.push(spacer);\n\t\t\t\t\tconst imageComponent = new Image(\n\t\t\t\t\t\timageData,\n\t\t\t\t\t\timageMimeType,\n\t\t\t\t\t\t{ fallbackColor: (s: string) => theme.fg(\"toolOutput\", s) },\n\t\t\t\t\t\t{ maxWidthCells: 60 },\n\t\t\t\t\t);\n\t\t\t\t\tthis.imageComponents.push(imageComponent);\n\t\t\t\t\tthis.addChild(imageComponent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Render bash content using visual line truncation (like bash-execution.ts)\n\t */\n\tprivate renderBashContent(): void {\n\t\tconst command = str(this.args?.command);\n\t\tconst timeout = this.args?.timeout as number | undefined;\n\n\t\t// Header\n\t\tconst timeoutSuffix = timeout ? theme.fg(\"muted\", ` (timeout ${timeout}s)`) : \"\";\n\t\tconst commandDisplay =\n\t\t\tcommand === null ? theme.fg(\"error\", \"[invalid arg]\") : command ? command : theme.fg(\"toolOutput\", \"...\");\n\t\tthis.contentBox.addChild(\n\t\t\tnew Text(theme.fg(\"toolTitle\", theme.bold(`$ ${commandDisplay}`)) + timeoutSuffix, 0, 0),\n\t\t);\n\n\t\tif (this.result) {\n\t\t\tconst output = this.getTextOutput().trim();\n\n\t\t\tif (output) {\n\t\t\t\t// Style each line for the output\n\t\t\t\tconst styledOutput = output\n\t\t\t\t\t.split(\"\\n\")\n\t\t\t\t\t.map((line) => theme.fg(\"toolOutput\", line))\n\t\t\t\t\t.join(\"\\n\");\n\n\t\t\t\tif (this.expanded) {\n\t\t\t\t\t// Show all lines when expanded\n\t\t\t\t\tthis.contentBox.addChild(new Text(`\\n${styledOutput}`, 0, 0));\n\t\t\t\t} else {\n\t\t\t\t\t// Use visual line truncation when collapsed with width-aware caching\n\t\t\t\t\tlet cachedWidth: number | undefined;\n\t\t\t\t\tlet cachedLines: string[] | undefined;\n\t\t\t\t\tlet cachedSkipped: number | undefined;\n\n\t\t\t\t\tthis.contentBox.addChild({\n\t\t\t\t\t\trender: (width: number) => {\n\t\t\t\t\t\t\tif (cachedLines === undefined || cachedWidth !== width) {\n\t\t\t\t\t\t\t\tconst result = truncateToVisualLines(styledOutput, BASH_PREVIEW_LINES, width);\n\t\t\t\t\t\t\t\tcachedLines = result.visualLines;\n\t\t\t\t\t\t\t\tcachedSkipped = result.skippedCount;\n\t\t\t\t\t\t\t\tcachedWidth = width;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (cachedSkipped && cachedSkipped > 0) {\n\t\t\t\t\t\t\t\tconst hint =\n\t\t\t\t\t\t\t\t\ttheme.fg(\"muted\", `... (${cachedSkipped} earlier lines,`) +\n\t\t\t\t\t\t\t\t\t` ${keyHint(\"expandTools\", \"to expand\")})`;\n\t\t\t\t\t\t\t\treturn [\"\", truncateToWidth(hint, width, \"...\"), ...cachedLines];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Add blank line for spacing (matches expanded case)\n\t\t\t\t\t\t\treturn [\"\", ...cachedLines];\n\t\t\t\t\t\t},\n\t\t\t\t\t\tinvalidate: () => {\n\t\t\t\t\t\t\tcachedWidth = undefined;\n\t\t\t\t\t\t\tcachedLines = undefined;\n\t\t\t\t\t\t\tcachedSkipped = undefined;\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Truncation warnings\n\t\t\tconst truncation = this.result.details?.truncation;\n\t\t\tconst fullOutputPath = this.result.details?.fullOutputPath;\n\t\t\tif (truncation?.truncated || fullOutputPath) {\n\t\t\t\tconst warnings: string[] = [];\n\t\t\t\tif (fullOutputPath) {\n\t\t\t\t\twarnings.push(`Full output: ${fullOutputPath}`);\n\t\t\t\t}\n\t\t\t\tif (truncation?.truncated) {\n\t\t\t\t\tif (truncation.truncatedBy === \"lines\") {\n\t\t\t\t\t\twarnings.push(`Truncated: showing ${truncation.outputLines} of ${truncation.totalLines} lines`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\twarnings.push(\n\t\t\t\t\t\t\t`Truncated: ${truncation.outputLines} lines shown (${formatSize(truncation.maxBytes ?? DEFAULT_MAX_BYTES)} limit)`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.contentBox.addChild(new Text(`\\n${theme.fg(\"warning\", `[${warnings.join(\". \")}]`)}`, 0, 0));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getTextOutput(): string {\n\t\tif (!this.result) return \"\";\n\n\t\tconst textBlocks = this.result.content?.filter((c: any) => c.type === \"text\") || [];\n\t\tconst imageBlocks = this.result.content?.filter((c: any) => c.type === \"image\") || [];\n\n\t\tlet output = textBlocks\n\t\t\t.map((c: any) => {\n\t\t\t\t// Use sanitizeBinaryOutput to handle binary data that crashes string-width\n\t\t\t\treturn sanitizeBinaryOutput(stripAnsi(c.text || \"\")).replace(/\\r/g, \"\");\n\t\t\t})\n\t\t\t.join(\"\\n\");\n\n\t\tconst caps = getCapabilities();\n\t\tif (imageBlocks.length > 0 && (!caps.images || !this.showImages)) {\n\t\t\tconst imageIndicators = imageBlocks\n\t\t\t\t.map((img: any) => {\n\t\t\t\t\tconst dims = img.data ? (getImageDimensions(img.data, img.mimeType) ?? undefined) : undefined;\n\t\t\t\t\treturn imageFallback(img.mimeType, dims);\n\t\t\t\t})\n\t\t\t\t.join(\"\\n\");\n\t\t\toutput = output ? `${output}\\n${imageIndicators}` : imageIndicators;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tprivate formatToolExecution(): string {\n\t\tlet text = \"\";\n\t\tconst invalidArg = theme.fg(\"error\", \"[invalid arg]\");\n\n\t\tif (this.toolName === \"read\") {\n\t\t\tconst rawPath = str(this.args?.file_path ?? this.args?.path);\n\t\t\tconst path = rawPath !== null ? shortenPath(rawPath) : null;\n\t\t\tconst offset = this.args?.offset;\n\t\t\tconst limit = this.args?.limit;\n\n\t\t\tlet pathDisplay = path === null ? invalidArg : path ? theme.fg(\"accent\", path) : theme.fg(\"toolOutput\", \"...\");\n\t\t\tif (offset !== undefined || limit !== undefined) {\n\t\t\t\tconst startLine = offset ?? 1;\n\t\t\t\tconst endLine = limit !== undefined ? startLine + limit - 1 : \"\";\n\t\t\t\tpathDisplay += theme.fg(\"warning\", `:${startLine}${endLine ? `-${endLine}` : \"\"}`);\n\t\t\t}\n\n\t\t\ttext = `${theme.fg(\"toolTitle\", theme.bold(\"read\"))} ${pathDisplay}`;\n\n\t\t\tif (this.result) {\n\t\t\t\tconst output = this.getTextOutput();\n\t\t\t\tconst rawPath = str(this.args?.file_path ?? this.args?.path);\n\t\t\t\tconst lang = rawPath ? getLanguageFromPath(rawPath) : undefined;\n\t\t\t\tconst lines = lang ? highlightCode(replaceTabs(output), lang) : output.split(\"\\n\");\n\n\t\t\t\tconst maxLines = this.expanded ? lines.length : 10;\n\t\t\t\tconst displayLines = lines.slice(0, maxLines);\n\t\t\t\tconst remaining = lines.length - maxLines;\n\n\t\t\t\ttext +=\n\t\t\t\t\t\"\\n\\n\" +\n\t\t\t\t\tdisplayLines\n\t\t\t\t\t\t.map((line: string) => (lang ? replaceTabs(line) : theme.fg(\"toolOutput\", replaceTabs(line))))\n\t\t\t\t\t\t.join(\"\\n\");\n\t\t\t\tif (remaining > 0) {\n\t\t\t\t\ttext += `${theme.fg(\"muted\", `\\n... (${remaining} more lines,`)} ${keyHint(\"expandTools\", \"to expand\")})`;\n\t\t\t\t}\n\n\t\t\t\tconst truncation = this.result.details?.truncation;\n\t\t\t\tif (truncation?.truncated) {\n\t\t\t\t\tif (truncation.firstLineExceedsLimit) {\n\t\t\t\t\t\ttext +=\n\t\t\t\t\t\t\t\"\\n\" +\n\t\t\t\t\t\t\ttheme.fg(\n\t\t\t\t\t\t\t\t\"warning\",\n\t\t\t\t\t\t\t\t`[First line exceeds ${formatSize(truncation.maxBytes ?? DEFAULT_MAX_BYTES)} limit]`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t} else if (truncation.truncatedBy === \"lines\") {\n\t\t\t\t\t\ttext +=\n\t\t\t\t\t\t\t\"\\n\" +\n\t\t\t\t\t\t\ttheme.fg(\n\t\t\t\t\t\t\t\t\"warning\",\n\t\t\t\t\t\t\t\t`[Truncated: showing ${truncation.outputLines} of ${truncation.totalLines} lines (${truncation.maxLines ?? DEFAULT_MAX_LINES} line limit)]`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttext +=\n\t\t\t\t\t\t\t\"\\n\" +\n\t\t\t\t\t\t\ttheme.fg(\n\t\t\t\t\t\t\t\t\"warning\",\n\t\t\t\t\t\t\t\t`[Truncated: ${truncation.outputLines} lines shown (${formatSize(truncation.maxBytes ?? DEFAULT_MAX_BYTES)} limit)]`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.toolName === \"write\") {\n\t\t\tconst rawPath = str(this.args?.file_path ?? this.args?.path);\n\t\t\tconst fileContent = str(this.args?.content);\n\t\t\tconst path = rawPath !== null ? shortenPath(rawPath) : null;\n\n\t\t\ttext =\n\t\t\t\ttheme.fg(\"toolTitle\", theme.bold(\"write\")) +\n\t\t\t\t\" \" +\n\t\t\t\t(path === null ? invalidArg : path ? theme.fg(\"accent\", path) : theme.fg(\"toolOutput\", \"...\"));\n\n\t\t\tif (fileContent === null) {\n\t\t\t\ttext += `\\n\\n${theme.fg(\"error\", \"[invalid content arg - expected string]\")}`;\n\t\t\t} else if (fileContent) {\n\t\t\t\tconst lang = rawPath ? getLanguageFromPath(rawPath) : undefined;\n\t\t\t\tconst lines = lang ? highlightCode(replaceTabs(fileContent), lang) : fileContent.split(\"\\n\");\n\t\t\t\tconst totalLines = lines.length;\n\t\t\t\tconst maxLines = this.expanded ? lines.length : 10;\n\t\t\t\tconst displayLines = lines.slice(0, maxLines);\n\t\t\t\tconst remaining = lines.length - maxLines;\n\n\t\t\t\ttext +=\n\t\t\t\t\t\"\\n\\n\" +\n\t\t\t\t\tdisplayLines\n\t\t\t\t\t\t.map((line: string) => (lang ? replaceTabs(line) : theme.fg(\"toolOutput\", replaceTabs(line))))\n\t\t\t\t\t\t.join(\"\\n\");\n\t\t\t\tif (remaining > 0) {\n\t\t\t\t\ttext +=\n\t\t\t\t\t\ttheme.fg(\"muted\", `\\n... (${remaining} more lines, ${totalLines} total,`) +\n\t\t\t\t\t\t` ${keyHint(\"expandTools\", \"to expand\")})`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Show error if tool execution failed\n\t\t\tif (this.result?.isError) {\n\t\t\t\tconst errorText = this.getTextOutput();\n\t\t\t\tif (errorText) {\n\t\t\t\t\ttext += `\\n\\n${theme.fg(\"error\", errorText)}`;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.toolName === \"edit\") {\n\t\t\tconst rawPath = str(this.args?.file_path ?? this.args?.path);\n\t\t\tconst path = rawPath !== null ? shortenPath(rawPath) : null;\n\n\t\t\t// Build path display, appending :line if we have diff info\n\t\t\tlet pathDisplay = path === null ? invalidArg : path ? theme.fg(\"accent\", path) : theme.fg(\"toolOutput\", \"...\");\n\t\t\tconst firstChangedLine =\n\t\t\t\t(this.editDiffPreview && \"firstChangedLine\" in this.editDiffPreview\n\t\t\t\t\t? this.editDiffPreview.firstChangedLine\n\t\t\t\t\t: undefined) ||\n\t\t\t\t(this.result && !this.result.isError ? this.result.details?.firstChangedLine : undefined);\n\t\t\tif (firstChangedLine) {\n\t\t\t\tpathDisplay += theme.fg(\"warning\", `:${firstChangedLine}`);\n\t\t\t}\n\n\t\t\ttext = `${theme.fg(\"toolTitle\", theme.bold(\"edit\"))} ${pathDisplay}`;\n\n\t\t\tif (this.result?.isError) {\n\t\t\t\t// Show error from result\n\t\t\t\tconst errorText = this.getTextOutput();\n\t\t\t\tif (errorText) {\n\t\t\t\t\ttext += `\\n\\n${theme.fg(\"error\", errorText)}`;\n\t\t\t\t}\n\t\t\t} else if (this.result?.details?.diff) {\n\t\t\t\t// Tool executed successfully - use the diff from result\n\t\t\t\t// This takes priority over editDiffPreview which may have a stale error\n\t\t\t\t// due to race condition (async preview computed after file was modified)\n\t\t\t\ttext += `\\n\\n${renderDiff(this.result.details.diff, { filePath: rawPath ?? undefined })}`;\n\t\t\t} else if (this.editDiffPreview) {\n\t\t\t\t// Use cached diff preview (before tool executes)\n\t\t\t\tif (\"error\" in this.editDiffPreview) {\n\t\t\t\t\ttext += `\\n\\n${theme.fg(\"error\", this.editDiffPreview.error)}`;\n\t\t\t\t} else if (this.editDiffPreview.diff) {\n\t\t\t\t\ttext += `\\n\\n${renderDiff(this.editDiffPreview.diff, { filePath: rawPath ?? undefined })}`;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.toolName === \"ls\") {\n\t\t\tconst rawPath = str(this.args?.path);\n\t\t\tconst path = rawPath !== null ? shortenPath(rawPath || \".\") : null;\n\t\t\tconst limit = this.args?.limit;\n\n\t\t\ttext = `${theme.fg(\"toolTitle\", theme.bold(\"ls\"))} ${path === null ? invalidArg : theme.fg(\"accent\", path)}`;\n\t\t\tif (limit !== undefined) {\n\t\t\t\ttext += theme.fg(\"toolOutput\", ` (limit ${limit})`);\n\t\t\t}\n\n\t\t\tif (this.result) {\n\t\t\t\tconst output = this.getTextOutput().trim();\n\t\t\t\tif (output) {\n\t\t\t\t\tconst lines = output.split(\"\\n\");\n\t\t\t\t\tconst maxLines = this.expanded ? lines.length : 20;\n\t\t\t\t\tconst displayLines = lines.slice(0, maxLines);\n\t\t\t\t\tconst remaining = lines.length - maxLines;\n\n\t\t\t\t\ttext += `\\n\\n${displayLines.map((line: string) => theme.fg(\"toolOutput\", line)).join(\"\\n\")}`;\n\t\t\t\t\tif (remaining > 0) {\n\t\t\t\t\t\ttext += `${theme.fg(\"muted\", `\\n... (${remaining} more lines,`)} ${keyHint(\"expandTools\", \"to expand\")})`;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst entryLimit = this.result.details?.entryLimitReached;\n\t\t\t\tconst truncation = this.result.details?.truncation;\n\t\t\t\tif (entryLimit || truncation?.truncated) {\n\t\t\t\t\tconst warnings: string[] = [];\n\t\t\t\t\tif (entryLimit) {\n\t\t\t\t\t\twarnings.push(`${entryLimit} entries limit`);\n\t\t\t\t\t}\n\t\t\t\t\tif (truncation?.truncated) {\n\t\t\t\t\t\twarnings.push(`${formatSize(truncation.maxBytes ?? DEFAULT_MAX_BYTES)} limit`);\n\t\t\t\t\t}\n\t\t\t\t\ttext += `\\n${theme.fg(\"warning\", `[Truncated: ${warnings.join(\", \")}]`)}`;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.toolName === \"find\") {\n\t\t\tconst pattern = str(this.args?.pattern);\n\t\t\tconst rawPath = str(this.args?.path);\n\t\t\tconst path = rawPath !== null ? shortenPath(rawPath || \".\") : null;\n\t\t\tconst limit = this.args?.limit;\n\n\t\t\ttext =\n\t\t\t\ttheme.fg(\"toolTitle\", theme.bold(\"find\")) +\n\t\t\t\t\" \" +\n\t\t\t\t(pattern === null ? invalidArg : theme.fg(\"accent\", pattern || \"\")) +\n\t\t\t\ttheme.fg(\"toolOutput\", ` in ${path === null ? invalidArg : path}`);\n\t\t\tif (limit !== undefined) {\n\t\t\t\ttext += theme.fg(\"toolOutput\", ` (limit ${limit})`);\n\t\t\t}\n\n\t\t\tif (this.result) {\n\t\t\t\tconst output = this.getTextOutput().trim();\n\t\t\t\tif (output) {\n\t\t\t\t\tconst lines = output.split(\"\\n\");\n\t\t\t\t\tconst maxLines = this.expanded ? lines.length : 20;\n\t\t\t\t\tconst displayLines = lines.slice(0, maxLines);\n\t\t\t\t\tconst remaining = lines.length - maxLines;\n\n\t\t\t\t\ttext += `\\n\\n${displayLines.map((line: string) => theme.fg(\"toolOutput\", line)).join(\"\\n\")}`;\n\t\t\t\t\tif (remaining > 0) {\n\t\t\t\t\t\ttext += `${theme.fg(\"muted\", `\\n... (${remaining} more lines,`)} ${keyHint(\"expandTools\", \"to expand\")})`;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst resultLimit = this.result.details?.resultLimitReached;\n\t\t\t\tconst truncation = this.result.details?.truncation;\n\t\t\t\tif (resultLimit || truncation?.truncated) {\n\t\t\t\t\tconst warnings: string[] = [];\n\t\t\t\t\tif (resultLimit) {\n\t\t\t\t\t\twarnings.push(`${resultLimit} results limit`);\n\t\t\t\t\t}\n\t\t\t\t\tif (truncation?.truncated) {\n\t\t\t\t\t\twarnings.push(`${formatSize(truncation.maxBytes ?? DEFAULT_MAX_BYTES)} limit`);\n\t\t\t\t\t}\n\t\t\t\t\ttext += `\\n${theme.fg(\"warning\", `[Truncated: ${warnings.join(\", \")}]`)}`;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.toolName === \"grep\") {\n\t\t\tconst pattern = str(this.args?.pattern);\n\t\t\tconst rawPath = str(this.args?.path);\n\t\t\tconst path = rawPath !== null ? shortenPath(rawPath || \".\") : null;\n\t\t\tconst glob = str(this.args?.glob);\n\t\t\tconst limit = this.args?.limit;\n\n\t\t\ttext =\n\t\t\t\ttheme.fg(\"toolTitle\", theme.bold(\"grep\")) +\n\t\t\t\t\" \" +\n\t\t\t\t(pattern === null ? invalidArg : theme.fg(\"accent\", `/${pattern || \"\"}/`)) +\n\t\t\t\ttheme.fg(\"toolOutput\", ` in ${path === null ? invalidArg : path}`);\n\t\t\tif (glob) {\n\t\t\t\ttext += theme.fg(\"toolOutput\", ` (${glob})`);\n\t\t\t}\n\t\t\tif (limit !== undefined) {\n\t\t\t\ttext += theme.fg(\"toolOutput\", ` limit ${limit}`);\n\t\t\t}\n\n\t\t\tif (this.result) {\n\t\t\t\tconst output = this.getTextOutput().trim();\n\t\t\t\tif (output) {\n\t\t\t\t\tconst lines = output.split(\"\\n\");\n\t\t\t\t\tconst maxLines = this.expanded ? lines.length : 15;\n\t\t\t\t\tconst displayLines = lines.slice(0, maxLines);\n\t\t\t\t\tconst remaining = lines.length - maxLines;\n\n\t\t\t\t\ttext += `\\n\\n${displayLines.map((line: string) => theme.fg(\"toolOutput\", line)).join(\"\\n\")}`;\n\t\t\t\t\tif (remaining > 0) {\n\t\t\t\t\t\ttext += `${theme.fg(\"muted\", `\\n... (${remaining} more lines,`)} ${keyHint(\"expandTools\", \"to expand\")})`;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst matchLimit = this.result.details?.matchLimitReached;\n\t\t\t\tconst truncation = this.result.details?.truncation;\n\t\t\t\tconst linesTruncated = this.result.details?.linesTruncated;\n\t\t\t\tif (matchLimit || truncation?.truncated || linesTruncated) {\n\t\t\t\t\tconst warnings: string[] = [];\n\t\t\t\t\tif (matchLimit) {\n\t\t\t\t\t\twarnings.push(`${matchLimit} matches limit`);\n\t\t\t\t\t}\n\t\t\t\t\tif (truncation?.truncated) {\n\t\t\t\t\t\twarnings.push(`${formatSize(truncation.maxBytes ?? DEFAULT_MAX_BYTES)} limit`);\n\t\t\t\t\t}\n\t\t\t\t\tif (linesTruncated) {\n\t\t\t\t\t\twarnings.push(\"some lines truncated\");\n\t\t\t\t\t}\n\t\t\t\t\ttext += `\\n${theme.fg(\"warning\", `[Truncated: ${warnings.join(\", \")}]`)}`;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Generic tool (shouldn't reach here for custom tools)\n\t\t\ttext = theme.fg(\"toolTitle\", theme.bold(this.toolName));\n\n\t\t\tconst content = JSON.stringify(this.args, null, 2);\n\t\t\ttext += `\\n\\n${content}`;\n\t\t\tconst output = this.getTextOutput();\n\t\t\tif (output) {\n\t\t\t\ttext += `\\n${output}`;\n\t\t\t}\n\t\t}\n\n\t\treturn text;\n\t}\n}\n"]}